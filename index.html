<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
    <script type="text/javascript" src="src/truckPaths.js"></script>
</head>
<body>

    <script>
    var config = {
        type: Phaser.AUTO,
            width: 768,
            height: 369,
        scene: {
            preload: preload,   
            create: create
        }
    };

    var game = new Phaser.Game(config);

    function preload ()
    {
        // load images
        this.load.image('background', 'assets/background.jpg');
        this.load.image('diceButton', 'assets/dicebutton.jpg');
        this.load.image('popup', 'assets/pop.jpg');
        this.load.image('close', 'assets/close.jpg');
        this.load.image('buggy', 'assets/buggy.jpg');
    }

    var button;
    var popup;
    var tween = null;

    function create ()
    {
        let money = 0;
        var diceRoll = 0;

        let bg = this.add.sprite(0, 0, 'background');
        bg.setScale(0.4);
        bg.setOrigin(0,0);

        // Add the roll dice button
        var diceRollText = this.add.text(700, 26, 'dice roll: n/a', { fontSize: '8px', fill: '#fff' });
        var rollDice = this.add.sprite(700, 46, 'diceButton').setInteractive();
        rollDice.setScale(0.3);
        rollDice.on('pointerdown', function (pointer) {
            this.setTint(0xff0000);
        });

        rollDice.on('pointerup', function (pointer) {
            this.clearTint();
            diceRoll = Math.floor(Math.random() * 6) + 1;
            diceRollText.setText('dice roll: ' + diceRoll);
        });
        
        // Iterate through each path and draw lines
        graphics = this.add.graphics();
        drawPath(whiteMine)
        drawPath(greenMine)
        drawPath(purpleMine)
        drawPath(blueMine)
        drawPath(redMine)
        drawPath(yellowMine)
        
        // 20x 20y is the lorry pool
        // var truck = this.add.sprite(20, 20, 'buggy', 0).setInteractive();
        // truck.setScale(0.02);
        
        button = this.add.button(game.world.centerX - 95, 460, 'buggy', openWindow, this, 2, 1, 0);
        button.input.useHandCursor = true;

        //  You can drag the pop-up window around
        popup = game.add.sprite(game.world.centerX, game.world.centerY, 'popup');
        popup.alpha = 0.8;
        popup.anchor.set(0.5);
        popup.inputEnabled = true;
        popup.input.enableDrag();

        //  Position the close button to the top-right of the popup sprite (minus 8px for spacing)
        var pw = (popup.width / 2) - 30;
        var ph = (popup.height / 2) - 8;

        //  And click the close button to close it down again
        var closeButton = game.make.sprite(pw, -ph, 'close');
        closeButton.inputEnabled = true;
        closeButton.input.priorityID = 1;
        closeButton.input.useHandCursor = true;
        closeButton.events.onInputDown.add(closeWindow, this);

        //  Add the "close button" to the popup window image
        popup.addChild(closeButton);

        //  Hide it awaiting a click
        popup.scale.set(0.1);
    }

    function openWindow() {

        if ((tween !== null && tween.isRunning) || popup.scale.x === 1) {
            return;
        }

        //  Create a tween that will pop-open the window, but only if it's not already tweening or open
        tween = game.add.tween(popup.scale).to( { x: 1, y: 1 }, 1000, Phaser.Easing.Elastic.Out, true);
    }

    function closeWindow() {
        if (tween && tween.isRunning || popup.scale.x === 0.1) {
            return;
        }

        //  Create a tween that will close the window, but only if it's not already tweening or closed
        tween = game.add.tween(popup.scale).to( { x: 0.1, y: 0.1 }, 500, Phaser.Easing.Elastic.In, true);
    }

    // Iterative function for looping through a path
    function traversePath(node, accumulator, stopValue) {
        graphics.lineStyle(2, 0xffffff, 1);
        node.neighbours.forEach(neighbour => {
            if(accumulator != stopValue) {
                traversePath(neighbour, accumulator + 1, stopValue);
            } else {
                graphics.fillStyle(0xffffff, 1);
                graphics.fillCircle(neighbour.x, neighbour.y, 8);
            }
        });
    }

    function drawPath(node) {
        graphics.lineStyle(2, 0xffffff, 1);
        node.neighbours.forEach(neighbour => {
            graphics.fillStyle(0xffff00, 1);
            graphics.lineBetween(neighbour.x, neighbour.y, node.x, node.y);
            graphics.fillCircle(neighbour.x, neighbour.y, 8);
            drawPath(neighbour);
        });
    }
    </script>

</body>
</html>